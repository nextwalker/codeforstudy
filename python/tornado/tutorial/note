1. Overview
    FriendFeed使用了一款使用 Python 编写的，相对简单的 非阻塞式 Web 服务器。
    其应用程序使用的 Web 框架看起来有些像 web.py 或者 Google 的 webapp， 不过为了能有效利用非阻塞式服务器环境，这个 Web 框架还包含了一些相关的有用工具 和优化。
    
    Tornado 就是我们在 FriendFeed 的 Web 服务器及其常用工具的开源版本。
    Tornado 和现在的主流 Web 服务器框架（包括大多数 Python 的框架）有着明显的区别：它是非阻塞式服务器，而且速度相当快。
    得利于其 非阻塞的方式和对 epoll 的运用，Tornado 每秒可以处理数以千计的连接，因此 Tornado 是实时 Web 服务的一个 理想框架。
    我们开发这个 Web 服务器的主要目的就是为了处理 FriendFeed 的实时功能 ——在 FriendFeed 的应用里每一个活动用户都会保持着一个服务器连接。
    （关于如何扩容 服务器，以处理数以千计的客户端的连接的问题，请参阅 The C10K problem ）
    
    启动
        application.listen(8888)
        tornado.ioloop.IOLoop.instance().start()
    
    我们清理了 Tornado 的基础代码，减少了各模块之间的相互依存关系，所以理论上讲， 你可以在自己的项目中独立地使用任何模块，而不需要使用整个包。
    
2. 下载和安装
    github库中包含相关的demo
    PycURL 依赖 
    
3. 模块索引
    主要模块
        web - FriendFeed 使用的基础 Web 框架，包含了 Tornado 的大多数重要的功能
        escape - XHTML, JSON, URL 的编码/解码方法
        database - 对 MySQLdb 的简单封装，使其更容易使用
        template - 基于 Python 的 web 模板系统
        httpclient - 非阻塞式 HTTP 客户端，它被设计用来和 web 及 httpserver 协同工作
        auth - 第三方认证的实现（包括 Google OpenID/OAuth、Facebook Platform、Yahoo BBAuth、FriendFeed OpenID/OAuth、Twitter OAuth）
        locale - 针对本地化和翻译的支持
        options - 命令行和配置文件解析工具，针对服务器环境做了优化
    底层模块
        httpserver - 服务于 web 模块的一个非常简单的 HTTP 服务器的实现
        iostream - 对非阻塞式的 socket 的简单封装，以方便常用读写操作
        ioloop - 核心的 I/O 循环
        
4. Tornado 攻略
    4.1 请求处理程序和请求参数
        Tornado的Web程序会将URL或者URL范式映射到tornado.web.RequestHandler的子类上去。
        在其子类中定义了 get() 或 post() 方法，用以处理不同的 HTTP 请求。
        你可以使用 get_argument() 方法来获取查询字符串参数，以及解析 POST 的内容
        上传的文件可以通过 self.request.files 访问到 该对象将名称（HTML元素 <input type="file">的 name 属性）对应到一个文件列表 
        每一个文件都以字典的形式 存在，其格式为 {"filename":..., "content_type":..., "body":...}
        
        返回 403 unauthorized, 只需要抛出一个 tornado.web.HTTPError 异常：
        if not self.user_is_logged_in():
            raise tornado.web.HTTPError(403)
        
        请求处理程序可以通过 self.request 访问到代表当前请求的对象。该 HTTPRequest 对象包含了一些有用的属性
            arguments - 所有的 GET 或 POST 的参数
            files - 所有通过 multipart/form-data POST 请求上传的文件
            path - 请求的路径（ ? 之前的所有内容）
            headers - 请求的开头信息
    
        print(a) => {'a': 2}
        
    4.2 重写 RequestHandler 的方法函数
        除了 get()/post()等以外，RequestHandler 中的一些别的方法函数，这都是 一些空函数，它们存在的目的是在必要时在子类中重新定义其内容。
        
        对于一个请求的处理 的代码调用次序如下：
        1. 程序为每一个请求创建一个 RequestHandler 对象
        2. 程序调用 initialize() 函数，这个函数的参数是 Application 配置中的关键字 参数定义。
            initialize 方法一般只是把传入的参数存 到成员变量中，而不会产生一些输出或者调用像 send_error 之类的方法。
            initialize 方法是 Tornado 1.1 中新添加的，旧版本中你需要 重写 __init__ 以达到同样的目的
        3. 程序调用 prepare()。无论使用了哪种 HTTP 方法，prepare 都会被调用到，因此 这个方法通常会被定义在一个基类中，然后在子类中重用。
            prepare可以产生输出 信息。如果它调用了finish（或send_error` 等函数），那么整个处理流程 就此结束。
        4. 程序调用某个 HTTP 方法：例如 get()、post()、put() 等。如果 URL 的正则表达式模式中有分组匹配，那么相关匹配会作为参数传入方法。
    
    重定向(redirect)
    模板
    Cookie 和安全 Cookie
    用户认证
    跨站伪造请求的防范
    静态文件和主动式文件缓存
    本地化
    UI 模块
    非阻塞式异步请求
    异步 HTTP 客户端
    第三方认证
    调试模式和自动重载
性能
生产环境下的部署
WSGI 和 Google AppEngine
注意事项和社区支持


mqtt liyong
