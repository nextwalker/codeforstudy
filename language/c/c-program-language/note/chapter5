第五章 指针与数组

指针是一种保存变量地址的变量。

& 取一个对象的地址 
* 间接寻址或间接引用运算符
地址运算符只能应用于内存中的对象，即变量和数组
不能作用于表达式、常量或者register类型的变量

int *p 该语句表明*ip的结果是int类型

指针只能某种特定类型的对象，也就是说，每个指针都必须指向某种特定的数据类型
（void类型的指针可以存放指向任何类型的指针，但他不能间接引用其自身）

++*ip = (*ip)++
类似于* ++ 这样的一员运算符遵循从右至左的结合顺序
iq = ip （复制指针，因为指针也是变量）

5.2 指针与函数参数
指针参数使得被调用函数能够访问和修改主调函数中对象的值

5.3 指针和数组
计算a[i] 实际上是先将其转换成*(a+i)的形式然后求值的。两种形式等价的
a + i = &a[i]
pa = &a[0] 等同于pa = a
数组加下标实现的表达式可等价地通过指针和偏移量实现

指针是一个变量，因此pa = a, pa++是合法的
数组名不是一个变量，因此a = pa, a++ 是非法的

数组名参数必须是一个指针，也就是一个存储地址值的变量（局部变量）
形式参数 char s[] 和 char *s
f(&a[2]) 与 f(a+2)

5.4 地址算术运算
alloc
afree
static 不可见
内存池
allocbuf 和 &allocbuf[0]等价的
C语言保证，0永远不是有效的数据地址，因此，返回0可用来表示发生了异常事件

指针与整数之间不能相互转换，但0是唯一的例外
常量0可以赋值给指针，指针也可以和常量0进行比较
常用符号常量NULL代替常量0，这样更清晰地说明常量0是指针的一个特殊值。
符号常量NULL定义在标准头文件<stddef.h>
指向同一数组的指针可以进行== != <= >=的关系比较运算
任何指针与0进行相等或不等的比较运算都有意义
指向不同数组的元素的指针之间的算术或比较运算没有意义。
指针的算数运算中可使用数组的最后一个元素的下一个元素的地址

p+n 表示指针p当前指向的对象之后第n个对象的地址。
p指向对象的长度取决于p的声明
int n*4 char n

q-p+1 两个指针之间元素的数目
指针的减法运算也是有意义的

可以测试 指针的计算地址运算不是单纯的数学运算

stddef.h 中定义的类型ptrdiff_t足以表示两个指针之间的带符号差值
size_t作为函数strlen的返回值类型（标准库）
size_t是由运算符sizeof返回的无符号整型。

指针的算数运算具有一致性。
浮点数，要把数组换成float类型。
p++, 将指向下一个浮点数的地址

所有的指针运算都会自动考虑它所指向的对象的长度。

有效的指针运算
有效的指针运算包括相同类型指针之间的赋值运算
指针同整数之间的加法或减法运算
指向相同数组中元素的两个指针间的减法或比较运算
将指针赋值为0或指针与0之间的比较运算

非法
不经强制类型转换而直接将指向一种类型对象的指针赋值给指向另一种类型对象的指针的运算(两个指针之一是void * 类型的情况除外）

5.5 字符指针与函数
字符串常量是一个字符数组  "I am a string"
在字符串的内部表示中，字符数组以空字符'\0'结尾，所以，程序可以通过检查空字符找到字符数组的结尾。
字符串常量占据的存储单元也因此比双引号内的字符数大1

字符串常量参数，本质传的是一个指向字符数组第一个字符的指针。
字符串常量可以通过一个指向第一个元素的指针访问

pmessage = "now is the time"; 字符串常量赋值
将把一个指向该字符数组的指针赋值给pmessage
该过程并没有进行字符串的复制，而只是涉及到指针的操作

C语言没有提供将整个字符串作为一个整体进行处理的运算符

char amessage[] = "now is the time";
char *pmessage  = "now is the time";
amessage是一个仅仅足以存放初始化字符串以及空字符'\0'的一维数组。
数组中的单个字符可以进行修改, 但amessage始终指向同一个存储位置。
pmessage是一个指针, 其初值指向一个字符串常量，之后它可以被修改指向其他的地址，但如果试图修改字符串的内容，结果是没有定义的。

strcpy(s, t);
*p++ 先加在访问 先访问再加 

5.6 指针数组以及指向指针的指针
指针数组 char *lineptr[MAXLINE]
指向字符指针的指针

5.7 多维数组
在C语言中，二维数组实际上是一种特殊的一维数组，它的每个元素也是一个一维数组。
二维数组参数
f(int daytab[2][13])
f(int daytab[][13])
f(int (*daytab)[13])
本质是传递一个指向很多对象的指针，其中每个对象是由13个整型元素构成的一维数组。
在函数的参数声明中必须指明数组的列数

int (*daytab)[13] 一个指针 指向具有13个整型元素的一维数组。
int *daytab[13] 一个数组，数组有13个元素，每个元素都是一个指向整型对象的指针。

一般来说，除数组的第一维(下标)可以不指定大小外，其余各维必须指定大小。

5.8 指针数组的初始化
char *name[] = {"january", "Februsary"}

5.9 指针和多维数组
int a[10][20]
int *b[10]
a 分配了200个int类型长度的存储单元
b 分配了10个指针，并且没有对他们进行初始化，它们的初始化必须以显示的方式进行，比如静态初始化火通过代码初始化

指针数组的一个重要有点在于，数组的每一行的长度可以不同。
char *name[]
char aname[][15]
的区别

5.10 命令行参数
argc 第一个参数 用于参数计数，命令行参数的数目
argv 第二个参数 用于参数向量，一个指向字符串数组的指针
argv[0] 该程序的程序名
argv[argc] ANSI标准要求必须为一个空指针

5.11 指向函数的指针
    在C语言中，函数本身不是变量，但可以定义指向函数的指针。
    这种类型的指针可以被赋值，存放在数组中，传递给函数，以及作为函数的返回值等等。
    
    int (*comp)(void *, void *)
    它表明comp是一个指向函数的指针，该函数具有两个void * 类型的参数，其返回值类型为int。
    
    (*comp)(v[i], v[left]) 第一个括号是必须的。
    comp是一个指向函数的指针，*comp代表一个函数
    int *comp(void *, void *)
    表明comp是一个函数，该函数返回一个指向int类型的指针。
    
5.12 复杂声明
    C语言的语法力图使声明和使用相一致。 简单的很有效，复杂的情况下，则很容易混淆。
    
    int *f()
    int (*pf)()
    *的优先级低于()
    
    
    

