# AKA学习笔记

## 术语，概念

在本章，我们尝试建立一组公用的术语，为探讨Akka所针对的并发，分布式系统建立坚实的基础。请注意，这些术语很多都没有公认的定义。我们仅仅寻求给出Akka文档范围内将被使用的可行定义。

### 并发 vs. 并行
并发和并行是相关的概念，但存在微妙的差别。 

- *并发* 意味着两个或更多的任务正在进行，尽管它们可能不会同时执行。例如这可以使用时间分片来实现，其中任务的小块被顺序执行， 与其他任务小块交替。
- *并行* 当任务真正同时执行时才成立。

### 异步 vs. 同步
- 方法调用被称作 *同步*的，如果在方法返回或跑出异常之前，调用者不能有任何进展。另一方面，*异步* 调用允许调用者在有限数量的步骤之后继续前进，并且方法的完成可以通过某些额外机制来告知调用者（可以是注册的回调，一个Future，或一个消息）。
- 一个同步*异步*的API可以使用阻塞来实现同步，但这不是必需的。高度CPU密集的任务可能表现出跟阻塞相似的行为。
- 总体来说，使用异步API是更好的，因为它们保证系统能够前进。Actor本质上是异步的：actor发送消息后可以继续前进，不必等待实际送达。

### 非阻塞 vs. 阻塞
- 我们谈论*阻塞*时，是说一个线程的延迟能够无限延迟其他的某些线程。一个很好的例子是，能够被一个线程通过互斥来独占使用的资源。如果一个线程无限持有这个资源(例如意外陷入无限循环)，其他等待这一资源的线程将无法前进。
- 相反，*非阻塞*的意思是，任何线程都不能无限延迟其他线程。
- 非阻塞的操作优于阻塞的操作，因为当包含阻塞操作时，就没法细致地保证系统的总体前进。

### 死锁 vs. 饥饿 vs. 活锁
- *死锁* 当多个参与者相互等待，达到一个特定状态后方可继续运行时发生。 由于它们当中任何一个都不能前进，除非其他参与者达到一个特定状态（一个"Catch-22"问题），因此所有受影响的子系统都会停滞。死锁与 *阻塞* 密切相关，因为死锁的一个必需条件是，一个参与者线程能够无限延迟其他线程的进行。 在 *死锁* 的情况下，任何参与者都不能取得进展。
- 而相反 *饥饿* 发生的情况是，有的参与者能够取得进展，但是有一个或多个不能。典型的场景是一个简陋的调度算法，总是优先选择高优先级的任务。如果到达的高优先级任务数量总是足够大，那么任何低优先级任务都不会完成。 
- *活锁* 类似于 *死锁* 的地方在于，任何参与者都不能取得进展。而区别在于，参与者不断改变其状态，而不是冻结在等待其他参与者前进的状态。一个示例场景是，两个参与者有两个等价的资源可用。它们每个都试图获取这个资源，但是它们还检查对方是否需要这一资源。如果这一资源被另一个参与者请求，那么就试着获取这一资源的另一个实例。在这种不幸的情况下，可能发生的是，两个参与者在两个资源之间“跳跃”，从不能获取它，但总是转到另一个资源。

### 竞态条件

- 我们称之为 *竞态条件* 的是对一组事件发生的顺序所做的假设可能被外在的不确定效果所破坏的情况。竞态条件总是发生于多个线程共享可变状态，并且线程对状态的操作可能交替进行，从而导致不可预期的行为的情况。尽管通常是这样，但共享状态并不一定具有竞态条件。例如一个客户端向服务器发送无序数据包（例如UDP数据报）``P1``, P2``时。 由于这些数据包可能经过不同的网络路径，服务器有可能会先收到``P2，后收到 ``P1`。如果消息未包含关于发送顺序的信息，那么就不可能通过服务器来识别它们发送的顺序不同。根据数据报的语义，这可能会导致竞态条件。
- Akka关于一对actor之间所发送的消息，唯一能够提供的保证是，它们的顺序总是会保留。参加 消息投递可靠性

### 非阻塞保证 (前进条件)
如之前小节所讨论，阻塞让人讨厌有若干原因，包括死锁和系统吞吐量下降的危险。在接下来的小节中，我们会讨论各种各样的不同强度的非阻塞性质。

#### 无等待
- 一个方法是*无等待*的，如果每次调用确保能够在有限数目的步骤内完成。如果一个方法是*有界无等待*，那么步骤的数目具有有限的上界。
- 根据这一定义能够断定，无等待的方法决不会阻塞，于是死锁不可能发生。此外，由于每个参与者都能在有限数量的步骤之后前进（当调用结束时），无等待的方法能免于饥饿。

#### 无锁
- *无锁* 跟 *无等待* 相比是更弱的性质。在无锁调用的情形下，无限频繁地，一些方法会在有限数量的步骤内完成。这个定义暗示了，对于无锁调用，死锁不可能发生。另一方面，*一些调用会在有限的步骤之内完成*的保证并不足以保证*它们之中所有都会最终完成* 。换句话说，无锁不足以保证不会饥饿。

#### 无干扰
- *无干扰* 是此处讨论的最弱的无阻塞保证。一个方法被称作*无干扰*的条件是，如果在某个时间点之后，它会孤立地执行（其他线程不能前进，例如：变为挂起），它会在有限数量的步骤之内完成。所有无锁对象都是无干扰的，但是反过来通常不成立。 
- 乐观并发控制 *乐观并发控制*(Optimistic concurrency control,OCC)方式通常是无干扰的。OCC方式就是，每个参与者都试图在共享对象上执行其操作，但是如果一个参与者检测到来自其他参与者的冲突，它会回滚修改，并且按照某种时间表来重试。如果有一个时间点参与者之中的一个是唯一一个正在尝试的，那么这个操作将会成功。

### 推荐的资料
- The Art of Multiprocessor Programming(多核编程的艺术), M. Herlihy and N Shavit, 2008. ISBN 978-0123705914
- Java Concurrency in Practice(并发编程实践), B. Goetz, T. Peierls, J. Bloch, J. Bowbeer, D. Holmes and D. Lea, 2006. ISBN 978-0321349606


