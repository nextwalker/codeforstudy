第六章 结构
结构是一个或多个变量的集合，一个单元，包含相关的多个变量

6.1 结构的基本知识
关键字struct引入结构声明，结构声明由包含在花括号内的一系列声明组成。
关键字struct后面的名字是可选的，称为结构标记（point）
结构标记用于为结构命名，在定义之后，结构标记就代表花括号内的声明，可以用它作为该声明的简写形式

结构中定义的变量称为成员
结构成员，结构标记和普通变量可以采用相同的名字。（不会冲突，因为通过上下文分析总可以对它们进行区分）
不同结构的成员可以使用相同的名字

struct声明定义了一种数据类型，后边可以跟变量表
struct {....} x, y, z; 类似于int x, y, z 声明指定类型的变量，并分配存储空间
不带变量表，不需要分配存储空间，仅仅描述了一种结构的模板和轮廓。
strcut point pt
strcut point maxpt = {320, 200} 初始化
初值必须是常量表达式

访问: 结构名.成员

结构可以嵌套

struct point {
	int x;
	int y;
}

struct rect {
	struct point pt1;
	struct point pt2;
}

struct rect screen; 
screen.pt1.x

6.2 结构与函数
结构和合法操作只有几种：
    作为一个整体赋值和复制
    通过&运算符取地址
    访问其成员
结构之间不可以进行比较
可以用一个常量成员值列表初始化结构，自动结构也可以通过赋值进行初始化

struct point *pp； 
(*pp).x 简写形式 pp->结构成员（pp是指向一个结构的指针） (p.x p是一个结构变量)
. -> () [] 优先级最高的

struct {
    int len;
    char *str
} *p;
++p->len 相当于 ++(p->len)
(++p)->len 先加1 再对len执行操作
(p++)->len 先对len执行操作，再加1

*p->str 读取的是指针str所指向的对象的值
*p->str++ 先读取指针str指向的对象的值，然后再将str加1（*s++相同）
(*p->str)++ 讲指针str指向的对象的值加1
*p++->str 先读取指针str指向的对象的值，然后再将p加1
 
6.3 结构数组
struct key {
    char *word;
    int count;
} keytab[NKEYS];
声明了一个结构类型key，并定义了该类型的结构数组keytab，同时分配存储空间。

struct key {
    char *word;
    int count;
} keytab[] = {
    "auto", 0,
    "break", 0,
    "default", 0
    "while", 0
}
因为结构keytab包含一个固定的名字集合，所以最好将它声明为外部变量。
{"auto", 0} 初值也要按照成对的方式给出，内层的花括号可以省略

keytab[] 机器可以自动计算长度，也是推荐的一种方式
另外一种办法，在初值表的结尾处加上一个空指针，然后循环遍历keytab，直到读到尾部的空指针为止。
项数 keytab的长度 /struct key的长度
sizeof用于计算任意对象的长度

sizeof 对象 或者 sizeof(类型)，将返回一个整型值，它等于指定对象或类型占用的存储空间字节数
sizeof 返回的是size_t 无符号整型值，定义于<stddef.h>
对象可以使变量、数组、结构
类型可以使int double基本类型，也可以是结构类型 指针类型等派生类型

#define NKEYS (sizeof keytab / sizeof(struct key))
#define NKEYS (sizeof keytab / sizeof(keytab[0]))

条件编译语句#if中不能使用sizeof，因为预处理器不对类型名进行分析。
#define使用sizeof是合法的，因为预处理器并不计算#define语句中的表达式  

6.4 指向结构的指针
结构的长度并不等于各成员长度的和。
因为不同的对象有不同的对齐要求，所以结构中可能会出现未命名的空穴 hole

6.5 自引用结构
一个包含其自身实例的结构是非法的，但是可以包含指向自身结构的指针

两个结构相互引用。(指针)

6.6 表查找
后边补充

6.7 类型定义 typedef
typedef 用来建立新的数据类型名
typedef int Length (将Length定义为与int具有同等意义的名字)
类型Length可用于类型声明，类型转换等，它和类型INT完全相同
Length *lengths[]

typedef char* String
String p, lineptr[MAXLINES], alloc(int); 
int strcmp(String, String);
p = (String) malloc(100);

typedef 语法上类似于存储类extern static等
typedef 定义的类型名的首字母要大写，以示区别。

typedef struct tnode *Treeptr;
typedef struct tnode { /* the tree node: */
    char *word;
    int count;
    struct tnode *left;
    struct tnode *right;
} Treenode;
Treenode 一个结构 TreePtr 一个指向该结构的指针
Treeptr talloc(void) {
    return (Treeptr) malloc(sizeof(Treenode));
}

从任何意义上讲，typedef声明并没有创建一个新的类型，它只是为某个已存在的类型增加了一个新的名称而已。
typedef声明也没有增加任何新的语义:通过这种方式声明的变量与通过普通声明方式声明的变量具有完全相同的属性。
实际上，typedef类似于#define语句，但是由于typedef是由编译器解释的，因此它的文本替换功能要超过预处理器的能力。

typedef int (*PFI)(char *, char *);
该语句定义了类型PFI是 一个指向函数的指针，该函数具有两个char *类型的参数，返回值类型为int。可用于某些上下文中
PFI strcmp, numcmp;

typedef 的优点
1. 表达方式更简洁
*2. 它可以使程序参数化，以提高程序的可移植性
    如果typedef声明的数据类型同机器有关，那么，当程序移植到其他机器上时，只需改变typedef类型的定义就可以了
    常用的情况，typedef定义一组合适的short int long 然后程序使用通过typedef定义的类型名
    size_t ptrdiff_t
*3 为程序提供更好的说明性 Treeptr

6.8 联合
联合是可以(在不同时刻)保存不同类型和长度的对象的变量，编译器负责跟踪对象的长度和对齐要求。
联合提供了一种方式，以在单块存储区域中管理不同类型的数据，而不需要在程序中嵌入任何同机器有关的信息。

联合的目的 一个变量可以合法地保存多种数据类型中的任何一种类型的对象。
特定类型的常量值必须保存在合适类型的变量中，然而，如果该常量的不同类型占据相同大小的存储空间，且保存在同一个地方的话，表管理将最方便。
int float 字符指针

union u_tag {
    int ival;
    float fval;
    char *sval;
}
