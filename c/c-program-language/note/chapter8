第八章 UNIX系统接口

UNIX操作系统通过一系列的系统调用提供服务，而这些系统调用实际上是操作系统内的函数，他们可以被用户程序调用。
需要借助系统调用已获取更高的效率或者访问标准库中没有的某些功能。
ANSI C标准函数库是以UNIX系统为基础建立起来的。

输入输出
文件系统
存储分配

标准库的输入输出接口对任何操作系统都是一样的。
在任何特定的系统中，标准库函数的实现必须通过宿主系统提供的功能来实现。

8.1 文件描述符
    在unix操作系统中，所有的外围设备（包括键盘和显示器）都被看作是文件系统中的文件，
    因此，所有的输入输出都要通过读文件或者写文件完成。也就是说，通过一个单一的接口就可以处理外围设备和程序之间的所有通信。
    
    通常情况下，在读或写文件之前，必须先将这个意图通知系统，该过程称为打开文件。
    如果是写一个文件，则可能需要先创建该文件，也可能需要丢弃该文件中原先已存在的内容。
    
    系统检查你的权力（该文件是否存在，是否有访问它的权限），如果一切正常，操作系统将向程序返回一个小的非负整数，该整数称为文件描述符。
    任何时候对文件的输入输出都是通过文件描述符识别文件，而不是通过文件名标识文件。
    (文件描述符类似于标准库中的文件指针或MS—DOS中的文件句柄。)
    
    系统负责维护已打开文件的所有信息，用户程序只能通过文件描述符引用文件。
    
    因为大多数的输入和输出是通过键盘和显示器来实现的，为了方便起见，unix对此做了特别的安排。
    当命令解释程序（shell）运行一个程序的时候，它将打开三个文件，对应的文件描述符分别为0，1，2，依次为标准输入 标准输出 标准错误
    如果程序从文件0中读，对1，2进行写，就可以进行输入输出而不必关心打开文件的问题。
    
    程序使用者可以通过< >重定向程序的IO
    prog < input file > output file
    这种情况下，shell把文件描述符0和1的默认赋值改变为指定的文件。
    通常，文件描述符2仍与显示器相关联，这样出错信息会输出到显示器上。
    与管道相关的输入、输出也有类似的特性。
    
    在任何的情况下，文件赋值的改变都不是由程序完成的，而是由shell完成的。
    只要程序使用文件0作为输入，文件1和2作为输出，它就不知道程序程序的输入从哪里来，并输出到哪里去。
    
8.2 低级IO read write
    输入与输出是通过read和write系统调用实现的。
    int n_read = read(int fd, char *buf, int n);
    int n_written = write(int fd, char *buf, int n);
    文件描述符 读写数据的字符数组 传输的字节数
    每个调用返回实际传输的字节数。
    
    在读文件时，函数的返回值可能会小于请求的字节数。
    如果返回值为0，则表示已达到文件的结尾。
    如果返回值为-1，则表示发生了某种错误。
    
    在写文件时，返回值是实际写入的字节数。
    如果返回值与请求写入的字节数不相等，则说明发生了错误。
    
    在一次调用中，读出或者写入的数据的字节数可以为任意大小。
    最常用的值为1，即每次读出或写入1个字符（无缓冲）,或是类似于1024-4096这样的与外围设备的物理块大小相对应的值。
    用更大的值调用该函数可以获取更高的效率，因为系统调用的次数减少了。
    
    BUFSIZ 对于所使用的操作系统来说，该值是一个较合适的数值。
    
    getchar
    #undef
    
8.3 open creat close unlink
    除了默认的标准输入 标准输出 和标准错误文件外，其他文件都必须在读或写之前显式地打开。 open creat用于实现该功能。
    
    open 返回一个int类型的数值 文件描述符，如果错误返回-1
    fopen 返回一个文件指针
    int open(char *name, int flags; int perms);
    name 包含文件名的字符串。
    flags 何种方式打开。 O_RDONLY 只读 O_WRONLY 只写 O_RDWR 读写
    System v UNIX 常量定义在<fcntl.h>
    BSD（berkeley）常量定义在<sys/file.h>
    int fd = open(name, O_RDONLY, 0)
    本章open的参数perms的值始终为0.
    
    如果用open打开一个不存在的文件，则将导致错误。可以使用creat系统调用创建新的文件火覆盖已有的旧文件。
    int creat(char *name, int perms);
    fd = creat(name, perms);
    如果creat成功地创建了文件，它将返回一个文件描述符，否则返回-1.
    如果此文件已存在，creat将把该文件的长度截断为0，从而丢弃原先已有的内容。
    使用creat创建一个已存在的文件不会导致错误。
    如果要创建的文件不存在，则creat用参数perms指定的权限创建文件。
    
    在unix文件系统中，每个文件对应一个9比特的权限信息，他们分别控制文件的所有者，所有者组和其他成员对文件的读写和执行访问。
    三位的八进制数 0755
    
    一个程序同时打开的文件数是有限制的，通常为20。相应地，如果一个程序需要同时处理许多文件，那么它必须重用文件描述符。
    函数close(int fd)用来断开文件描述符和已打开文件之间的连接，并释放此文件描述符，以供其它文件使用。
    close函数与标准库中的fclose函数相对应，但它不需要清洗(flush)缓冲区。
    如果程序通过exit函数退出或从主程序中返回，所有打开的文件将被关闭。
    
    函数unlink(char *name)将文件name从文件系统中删除，他对应与标准库函数remove。
    
8.4 随机访问 lseek
    输入输出通常是顺序进行的。每次调用read和write进行读写的位置紧跟在前一次操作的位置之后。
    任意顺序访问文件
    系统调用lseek可以在文件中任意移动位置而不实际读写任何数据。
    long lseek(int fd, long offset, int origin);
    将文件描述符为fd的文件的当前位置设置为offset，其中offset是相对于origin指定的位置而言的，随后进行的读写操作将从此位置开始。
    origin的值可以为0,1或2, 分别用于指定offset从文件开始，从当前位置或从文件结束处开始算起。
    
    文件尾部添加内容（shell中的重定向符>> 或在系统调用fopen中使用参数"a"）
    lseek(fd, 0L, 2);
    若要返回文件的开始处(即反绕)
    lseek(fd, 0L, 0);
    参数0L 也可以写成(long)0, 或仅仅写为0，但是系统调用lseek的声明必须保持一致。
    
    使用lseek系统调用时，可以将文件视为一个大数组，其代价就是访问速度会慢一些。
    
    任意位置读入任意数目的字节的函数
    
    lseek系统调用返回一个long类型的值，此值表示文件的新位置，若发生错误，则返回-1.
    fseek 不同之处 第一个参数是FILE*类型，且在发生错误时返回一个非0值。
    
    
    

8.5 实例 fopen getc函数的实现

8.6 实例 目录列表

8.7 实例 存储分配程序