### UNIX环境高级编程

----

#### 第三章 文件I/O
study date: 2014-04-07

##### 3.1 引言

	文件IO函数 打开文件、读文件、写文件 open read write lseek close
	unbuffered I/O 不带缓冲是指每个read和write都调用内核中的一个系统调用。
	不是ISO C的组成部分，是POSIX和Single UNIX specification的组成部分。

##### 3.2 文件描述符
	
	对于内核而言，所有打开的文件都通过文件描述符引用
	文件描述符是一个非负整数。open和create返回。
	标准惯例 0标准输入 1标准输出 2标准错误输出
	POSIX标准 unistd.h 定义 STDIN_FILENO STDOUT_FILENO STDERR_FILENO
	
	文件描述符的变化范围是0~OPEN_MAX，代表允许每个进程最多打开的文件
	UNIX早期19，现在增至63，linux的限制1048576，mac无限的。
	
##### 3.3 open函数

	调用open函数可以打开或创建一个文件
	#include <fcntl.h>
	int open(const char *pathname, int oflag, ... /* mode_t mode */);
	返回值：若成功则返回文件描述符，若出错则返回-1
	
	第三个参数... ISO C用这种方法表明余下参数的数量及其类型根据具体的调用会所有不同。
	open函数仅当创建新文件时才使用第三个参数。
	
	pathname 要打开或创建文件的名字。
	
##### 3.4 creat函数

	调用creat函数创建一个新文件
	#include <fcntl.h>
	int create(const char *pathname, mode_t mode)
	返回值：若成功则返回为只写打开的文件描述符，若出错则返回-1
	
	此函数等效于 open(pathname, O_WRONLY | O_CREAT | O_TRUNC, mode);
	
	旧版本时， creat，close，open
	新版本open，open(pathname, O_RDWR | O_CREAT | O_TRUNC, mode);
	
##### 3.5 close函数

	调用close函数关闭一个打开的文件
	#include <unistd.h>
	int close(int filedes);
	返回值：若成功返回0，若出错则返回-1
	
	关闭一个文件时还会释放该进程加在该文件上的所有记录锁。
	当一个进程终止时，内核自动关闭它所有打开的文件。很多程序利用这一功能而不显式地调用close关闭打开的文件。
	
##### 3.6 lseek函数

	当前文件偏移量，current file offset
	每个打开的文件都有一个与其相关联的当前文件偏移量。
	通常是非负整数，用以度量从文件开始处计算的字节数。
	读写操作都是从当前文件偏移量处开始，并使偏移量增加所读写的字节数。
	系统默认，当打开一个文件，除非指定O_APPEND选项，否则该偏移量被设置为0
	
	调用lseek显式地为一个打开的文件设置其偏移量
	#include <unistd.h>
	off_t lseek(int filedes, off_t offset, int where);
	返回值，若成功则返回新的文件的偏移量，若出错则返回-1
	
	参数解释
	当where是SEEK_SET, 则将该文件的偏移量设置为距文件开始处offset个字节
	当where是SEEK_CUR, 则将该文件的偏移量设置为其当前值加offset，offset可为正或负。
	当where是SEEK_END, 则将该文件的偏移量设置为文件长度加offset，offset可为正或负。

	以下方式可以确定打开文件的当前偏移量。
	off_t currpos = lseek(fd, 0, SEEK_CUR);
	这种方法也可以用来确定所涉及的文件是否可以设置偏移量。
	若文件描述符引用的是一个管道、FIFO或网络套接字，则lseek返回-1，并将error设置为ESPIPE
	
	系统V引入三个符号常量，SEEK_SET, SEEK_CUR, SEEK_END.
	系统V之前，where被指定为0，(绝对偏移量) 1，（相对当前位置偏移量） 2（相对文件尾端的偏移量）
	
	lseek中的字符l表示长整形。在引入off_t数据类型之前，offset的参数和返回值都是长整形。
	
	通常文件的当前偏移量应当是一个非负整数，但是某些设备也可能允许负的偏移量。
	相对于普通文件，则偏移量必须是非负值。
	比较返回lseek的返回值，要测试是否等于-1，而不要测试它是否小于0
	
	lseek仅将当前的文件偏移量记录在内核中，他并不引起任何IO操作。然后，该偏移量用于下一次读或写操作。
	文件偏移量可以大于文件的当前长度，这种情况下，对该文件的下一次写将加长该文件，并在文件中构成一个空洞。位于文件中但没有写过的字节都被读为0.
	文件中的空洞并不要求在磁盘上占用存储区。具体的处理方式与文件系统的实现有关。
	新写的数据需要分配磁盘快，原文件尾端和先开始写位置之间的部分（空洞）不需要分配磁盘。
	
##### 3.7 read函数

	调用read函数从打开的文件中读取数据
	#include <unistd.h>
	ssize_t read(int filedes, void *buf, size_t nbytes);
	返回值：若成功则返回读到的字节数，若已到文件的结尾则返回0，若出现错误则返回-1
	
	有多种情况可使实际读到的字节数小于要求读的字节数
	1. 读普通文件，在读到要求字节数之前已到达文件尾端。30读100 返回30，下次返回0
	2. 当从终端设备读时，通常一次最多读一行（可改变）
	3. 当从网络读时，网络中缓冲机构可能造成返回值小于所要求读的字节数
	4. 当从管道或FIFO读时，如若管道中包含的字节小于所需的数量，那么read将只返回实际可用的字节数
	5. 当从某些面向记录的设备（如磁带）读时，一次最多返回一个记录。
	6. 当某一信号造成中断，而已经读了部分数据量时。
	
	读操作从文件的当前偏移量处开始，在成功返回之前，该偏移量增加实际读到的字节数。
	
	经典定义 int read(int filedes, char *buf, unsigned nbytes);
	在ISO C中，类型void *用于表示通用指针。
	带符号整数ssize_t 正字节数 0（文件尾端） -1 （出错）
	
	1990 posix标准引入
	基本数据类型ssize_t以提供带符号的返回值
	不带符号的size_t用于第三个参数(SSIZE_MAX常量) ？
	
##### 3.8 write函数
	
	调用write函数向打开的文件写数据
	#include <unistd.h>
	ssize_t write(int filedes, const void *buf, size_t nbytes);
	返回值：若成功则返回已写的字节数，若出错则返回-1
	
	其返回值通常与参数nbytes的值相同，否则表示出错。
	write出错的一个常见原因是，磁盘已写满，或者超过一个给定进程的文件长度限制。
	
	普通文件，写操作从当前的文件偏移量处开始。
	打开文件，指定O_APPEND选项，则在每次写操作之前，将文件的偏移量设置在文件的当前结尾处，再一次成功写之后，该文件偏移量增加实际写的字节数。
	
##### 3.9 IO效率

	1. 标准输入读，标准输出写，UNIX系统shell默认自动打开标准输入和标准输出
	2. 标准输入和标准输出的文件描述符分别是0和1.在<unistd.h>定义了STDIN_FILENO, STDOUT_FILENO
	3. 程序终止时，UNIX系统内核会关闭该进程的所有打开的文件描述符。可以不用关闭输入输出文件
	4. 对UNIX系统而言，文本文件和二进制代码文件并无区别
	
	不同缓存长度，读效率的结果 linux ex2 块长4096 在BUFFSIZE是4096处，cpu时间最小
	
	大多数文件系统为改善其性能都采用某种预读技术，read ahead。当检测到正进行顺序读取时，系统就试图读入比应用程序所要求的更多数据，并假想应用程序很快就会读这些数据。
	
	操作系统试图用缓存技术将相关文件放置在主存中，所以，重复度量程序性能，那么后续的运行该程序所得到的计时很可能会好于第一次。原因是，系统缓存，减少了磁盘读写。
	
##### 3.10 文件共享

	unix系统支持在不同进程间共享打开文件。
	
	下面是概念性的，系统的实现是特定的。
	
	内核使用三种数据结构表示打开的文件，他们之间的关系决定了在文件共享方面一个进程对另一个进程可能产生的影响
	1. 每个进程在进程表中都有一个记录项，记录项中包含有一张打开文件描述符表。可将其视为一个矢量，每个描述符占用一项。关联
		a 文件描述符标志 （close_on_exec）
		b 指向一个文件表项的指针
	2. 内核为所有打开文件维持一张文件表。包含
		a 文件状态标志，读、写、添写、同步和非阻赛等
		b 当前文件的偏移量
		c 指向该文件v节点表项的指针。
	3. 每个打开文件(或设备)都有一个V节点结构。
		v节点包含了文件类型和对此文件进行各种操作的函数的指针。
		对于大多数文件，v节点还包含了该文件的i节点 i-node 索引节点
		这些信息是在打开文件时从磁盘上读入内存的，所以所有关于文件的信息都是快速可供使用的。
		i节点包含了文件的所有者，文件长度，文件所在的设备，指向文件实际数据块在磁盘上所在位置的指针等。
		linux没有使用v节点，而是使用了通用的I节点结构。
	
	进程表项 fd标志和文件指针（文件表）
	文件表   文件状态标志，当前文件偏移量 v节点指针（v节点表）
	v节点表  v节点信息 i节点信息 当前文件长度
	
	创建v节点结构的目的是对在一个计算机系统上的多文件系统类型提供支持。
	sun称此文件系统为虚拟文件系统virtual file system
	称与文件系统类型无关的i节点部分为v节点。
	SVR4 v节点（与文件系统类型无关的i节点结构）
	linux 没有将相关数据结构分为i节点和v节点，而是采用了一个独立于文件系统结构的i节点和一个依赖文件系统的i节点。
	
	打开文件的每个进程都会得到各自独立的一个文件表项，但是对于一个给定的文件只有一个V节点表项。
	不同进程打开同一文件，各自独立的文件表项，可使每个进程都有他自己的对该文件的当前偏移量
	
	在完成每个write后，在文件表项中的当前文件偏移量即增加的所写的字节数。如果这使当前文件偏移量超过了当前文件长度，则在i节点表项中的当前文件长度被设置为当前文件的偏移量，文件加长了。
	如果用O_APPEND标志打开了一个文件，则相应标志也被设置到文件表项的文件状态标志中。每次对具有这种添写标志的文件执行写操作时，在文件表项中的当前文件偏移量首先被设置为i节点表项中的文件长度。这样可使每次写数据都添加到文件的当前尾端处。
	若一个文件用lseek定位到文件当前的尾端，则文件表项中的当前文件偏移量被设置为i节点表项中的当前文件长度。这与用O_APPEND标志打开文件是不同的。
	lseek函数只修改文件表项中的当前文件偏移量，没有进行任何IO操作。
	
	注意：
	可能有多个文件描述符项指向同一个文件表项，dup函数，fork子进程。
	文件描述符和文件状态标志在作用域方面的区别，前者只用于一个进程的一个描述符，而后者则适用于指向该给定文件表项的任何进程的所有描述符。fcntl函数。
	
	多进程读取同一文件，每个进程都有它自己的文件表项，其中也又自己的当前文件偏移量。读操作没有问题，写操作可能产生预期不到的结果。
	
##### 3.11 原子操作

	1. 添写至一个文件
	早期没有O_APPEND选项，多进程写的时候，就可能会出现覆盖的情况。
	if (lseek(fd, 0L, 2) < 0)
		err_sys("lseek error");
	if (wirte(fd, buf, 100) != 100)
		err_sys("write error")
	问题出在逻辑操作“定位到文件尾端处，然后写”上，它使用了两个分开的函数调用。解决问题的办法是使这两个操作对于其他进程而言成为一个原子操作。任何一个需要多个函数调用的操作都不可能是原子操作，因为这两个函数调用之间，内核有可能会临时挂起该进程。
	O_APPEND标志，每次写都讲进程的当前偏移量设置到文件的尾端处，而不需要调用lseek
	
	2. pread和pwrite函数
	single unix specification包括了XSI扩展，该扩展允许原子性地定位搜索和执行IO。pread和pwrite就是这种扩展。
	#include <unistd.h>
	ssize_t pread(int filedes, void * buf, size_t nbytes, off_t offset);
		返回值，读到的字节数，若已到文件结尾则返回0，若出错则返回-1
	sszie_t pwrite(int filedes, const void * buf, size_t nbytes, off_t offset);
		返回值，若成功则返回已写的字节数，若出错则返回-1
	调用pread相当于顺序调用lseek和read，但又与之有重要区别
	- 调用pread函数时，无法中断其定位和读操作，
	- 不更新文件指针。（不更新文件指针会带来什么问题？？）
	pwrite和也是类似的。
	
	3. 创建一个文件
	在对open函数的O_CREATE和O_EXCL选项时，也是一种原子操作。
	检查该文件是否存在以及创建该文件这两个操作是作为一个原子操作执行的。
	如果不是原子操作，就会出现误判和覆盖的问题。原子操作就不会产生这个问题。
	
	原子操作atomic operation指的是由多步组成的操作，如果该操作原子地执行，则要麽执行完所有的步骤，要麽一步也不执行，不可能只执行所有步骤的一个子集。
	
##### 3.12 dup和dup2函数

	dup和dup2函数都可用来复制一个现存的文件描述符
	#include <unistd.h>
	int dup(int filedes);
	int dup2(int filedes, int filedes2);
	两函数的返回值，若成功则返回新的文件描述符，若出错则返回-1.
	
	dup返回新的文件描述符一定是当前可用文件描述符中的最小数值。
	dup2则可以用filedes2参数指定新描述符的数值。如果filed2已经打开，则先将其关闭，如若filedes等于fieldes2，则直接返回filedes2.
	
	返回的新文件描述符与参数filedes共享同一文件表项，因此他们共享同一文件状态的标志（读，写，添写）以及同一当前文件偏移量。
	每个文件描述符都有它自己的一套文件描述符标志。？？
	新描述符的执行时关闭标志总是由dup函数清除。
	
	复制一个描述符的另一种方法是fcntl函数
	dup(filedes) 等效于 fcntl(filedes, F_DUPFD, 0);
	dup2(filedes filedes2) 等效于 close(filedes2); fcntl(filedes, F_DUPFD, filedes2)
	第二种之间的区别，
	dup2是一个原子操作，而close和fcntl则包括两个函数调用。有可能在close和fcntl之间插入执行信号捕获函数，它可能修改文件描述符。
	dup和fcntl有某些不同的error。
	
##### 3.13 sync，fsync和fdatasync
	
	延迟写  delayed write
	传统的unix实现在内核中设有缓冲区高度缓存或页面高速缓存，大多数磁盘IO都通过缓冲进行。当将数据写入文件时，内核通常先将该文件复制到某一个缓冲区，如果该缓冲区尚未写满，则并不将其排入输出队列，而是等待其写满或者内核需要重用该缓存区以便存放其他磁盘块数据时，再将该缓冲排入输出队列。然后待其达到队首时，才进行实际的IO操作。
	
	延迟写减少了磁盘读写次数，但是却降低了文件内容的更新速度，使得欲写到文件中的数据在一段时间内并没有写到磁盘上，当系统发生故障，这种延迟可能造成文件更新内容的丢失。
	
	为了保证磁盘上实际文件系统与缓冲区高速缓存中内容的一致性，unix提供了三个函数
	#include <unistd.h>
	int fsync(int filedes);
	int fdatasyne(int filedes);
		返回值，若成功则返回0，若出错则返回-1
	void sync(viod);
	
	sync函数只是将所有修改过的块缓冲区排入写队列，然后就返回，他并不等待实际写磁盘操作结束。
	通常成为update的系统守护进程会周期性地(一般每隔30秒)调用sync函数。这就保证了定期冲洗内核的块缓冲区。命令sync(1)也调用sync函数。
	fsync函数只对有文件描述符filedes指定的单一文件起作用，并且等待写磁盘操作结束，然后返回。fsync可用于数据库这样的应用程序，这种应用程序需要确保修改过的块立即写入到磁盘上。
	fdatasync函数类似于fsync，但它只影响文件的数据部分，而除数据外，fsync还会同步更新文件的属性。
	
##### 3.14 fcntl函数
	
		fcntl函数可以改变已打开的文件的性质。
		#include <fcntl.h>
		int fcntl(int filedes, int cmd, ... /* int arg */);
		返回值，若成功则依赖于cmd，若出错则返回-1
		
#### 第四章 文件和目录

##### 4.1 引言
	文件系统的其他特征和文件性质

##### 4.2 stat fstat lstat

	#inlcude <sys/stat.h>
	int stat(const char *restrict pathname, struct stat *restrict buf);
	int fstat(int filedes, struct stat * buf);
	int lstat(const char *restrict pathname, struct stat *restrict buf);
	若成功则返回0, 若出错则返回-1.
	
	stat函数返回与pathname命名文件有关的信息结构。
	fstat函数获取已在文件描述符filedes上打开文件的有关信息
	lstat返回符号连接的有关信息，而不是由该符号链接引用文件的信息。（应用于符号链接文件）
	
	struct stat {
		mode_t	st_mode; 	// file type & mode (permissions)
		ino_t	st_ino;		// i-node number (serial number)
		dev_t	st_dev;		// device number file system
		dev_t	st_redev;	// device number for special files
		nlink_t	st_nlink;	// number of links
		uid_t	st_uid;		// user ID of owner
		git_t	st_gid;		// group ID of owner
		off_t	st_size;	// size in bytes, for regular files
		time_t	st_atime;	// time of last access
		time_t	st_mtime;	// time of last modification
		time_t	st_ctime;	// time of last file status change
		blksize_t st_blksize; // best IO block size
		blkcnt_t  st_blocks;  // number of disk block allocated
	}
	不同系统的实现会不一样，但是是类似的。
	ls -l 使用stat函数
	
##### 4.3 文件类型
	
	1. 普通文件 regular file
	2. 目录文件 directory file
	3. 块特殊文件 block special file
	4. 字符特殊文件 character special file
	5. FIFO 管道 
	6. 套接字 socket
	7. 符号链接 symbolic link
	
	普通文件，最常用的文件类型，包含了某种形式的数据。至于这种数据是文本还是二进制数据对于unix内核而言并无区别。对普通文件的解释由处理该文件的应用程序进行。
	特殊：二进制可执行文件是例外。为了执行程序，内核必须理解其格式。所有二进制可执行文件都是遵循一种格式，这种格式使内核能够确定程序文件和数据的加载位置。
	目录文件，这种文件包含了其他文件的名字以及指向与这些文件有关信息的指针。对于目录文件具有读权限的任一进程都可以读该目录的内容，但只有内核可以直接写目录文件。进程必须使用本章说明的函数才能更改目录。
	块特殊文件，这种文件类型提供对设备例如磁盘带缓冲的访问，每次访问以固定长度为单位进行。
	字符特殊文件，这种文件类型提供对设备不带缓冲的访问，每次访问长度可变。系统中所有的设备要麽是字符特殊文件，要麽是快特殊文件。
	FIFO，这种文件类型用于进程间的网络通信，有时也将其命名为管道。named pipe。
	套接字，这种文件类型用于进程间的网络通信。套接字也可用于在一台宿主机上进程之间的非网络通信。
	符号链接，这种文件类型指向另一个文件。
	
	文件类型的信息包含在stat结构的st_mode成员中。
	可以用下面的宏来确定文件类型，这些宏的参数都是stat结构的st_mode成员。
	<sys/stat.h> 文件类型宏
	S_ISREG()
	S_ISDIR()
	S_ISCHR()  字符特殊文件
	S_ISBLK()  块特殊文件
	S_ISFIFO() 管道或FIFO
	S_ISLNK()  符号连接
	S_ISSOCK()
	
	POSIX.1 允许实现将进程间通信(IPC)对象（例如，消息队列和信号量）表示为文件。
	这些宏来确定IPC对象的类型，他们的参数是stat结构的指针。
	<sys/stat.h>中的IPC类型宏
	S_TYPEISMQ()  消息队列
	S_TYPEISSEM() 信号量
	S_TYPEISSHM() 共享存储对象
	本书讨论的四种unix系统都不将这些对象表示为文件。
	
	
	